# Runtime Schema

ComposeDB automatically generates the runtime GraphQL schema used by applications to interact with their composites.

## Objects

### Document objects

Documents are uniquelly identifiable objects in the graph using [GraphQL's Global Object Identification](https://graphql.org/learn/global-object-identification/) specification with the `Node` interface. All document objects contain an `id: ID!` field representing their unique stream ID.

The other fields present in document objects are generated based on the [model's definition](../../guides/data-modeling/writing-models.mdx) and possibly added [views](../sdl/directives.mdx#views).

For example, using the following [Schema definition](../../guides/data-modeling/schemas.mdx):

```graphql
enum PostStatus {
  ARCHIVED
  DRAFT
  PUBLISHED
}

type Post @createModel(accountRelation: LIST, description: "A simple post") {
  author: DID! @documentAccount
  status: PostStatus!
  publicationDate: DateTime
  title: String! @string(minLength: 5, maxLength: 100)
  text: String! @string(minLength: 5, maxLength: 10000)
}
```

This runtime schema will be generated:

```graphql
# ℹ️ Some types are omitted in this example for brievity

type CeramicAccount implements Node {
  # Default fields always present on the CeramicAccount object
  id: ID!
  isViewer: Boolean!
  # Added connection to Post documents controlled by the account
  postList: PostConnection
}

enum PostStatus {
  ARCHIVED
  DRAFT
  PUBLISHED
}

type Post implements Node {
  # The ID field representing the document stream ID is always added to document objects
  id: ID!
  # DID scalar field converted to CeramicAccount object
  author: CeramicAccount!
  # Other fields defined in the schema
  status: PostStatus!
  publicationDate: DateTime
  title: String!
  text: String!
}

type PostConnection {
  edges: [PostEdge]
  pageInfo: PageInfo
}

type PostEdge {
  cursor: String
  node: Post
}
```

### Embedded objects

Embedded objects can only be accessed from the document storing them.

Example [Schema definition](../../guides/data-modeling/schemas.mdx):

```graphql
type ImageSource {
  src: URI!
  alt: String! @string(minLength: 5, maxLength: 100)
  width: Int
  height: Int
}

type ImageMetadata {
  original: ImageSource!
  alternatives: [ImageSource!]!
}

type Profile @createModel(accountRelation: SINGLE, description: "A basic profile") {
  displayName: String! @string(minLength: 5, maxLength: 100)
  avatar: ImageMetadata
}

type Post @createModel(accountRelation: LIST, description: "A simple post") {
  title: String! @string(minLength: 5, maxLength: 100)
  cover: ImageMetadata
}
```

This runtime schema will be generated:

```graphql
# ℹ️ Some types are omitted in this example for brievity

type PostImageMetadata {
  original: PostImageSource!
  alternatives: [PostImageSource!]!
}

type PostImageSource {
  src: URI!
  alt: String!
  width: Int
  height: Int
}

type Post implements Node {
  id: ID!
  title: String!
  cover: PostImageMetadata
}

type ProfileImageMetadata {
  original: ProfileImageSource!
  alternatives: [ProfileImageSource!]!
}

type ProfileImageSource {
  src: URI!
  alt: String!
  width: Int
  height: Int
}

type Profile implements Node {
  id: ID!
  displayName: String!
  avatar: ProfileImageMetadata
}
```

In the runtime schema above, the `ImageMetadata` and `ImageSources` objects from the schema definition are generated as `PostImageMetadata`, `PostImageSources`, `ProfileImageMetadata` and `ProfileImageSources` to avoid conflicts between embedded objects.

Using the [`setCommomEmbeds()` method of the `Composite` class](../classes/devtools.Composite.md#setcommonembeds), it is possible to specify that embedded objects can be safely shared by multiple documents, generating the following runtime schema:

```graphql
# ℹ️ Some types are omitted in this example for brievity

type ImageMetadata {
  original: ImageSource!
  alternatives: [ImageSource!]!
}

type ImageSource {
  src: URI!
  alt: String!
  width: Int
  height: Int
}

type Post implements Node {
  id: ID!
  title: String!
  cover: ImageMetadata
}

type Profile implements Node {
  id: ID!
  displayName: String!
  avatar: ImageMetadata
}
```

### `CeramicAccount` object

The `CeramicAccount` object is generated to represent any DID and its associated documents in the network.

Similar to [Document objects](#document-objects), all `CeramicAccount` objects are uniquelly identifiable objects in the graph using [GraphQL's Global Object Identification](https://graphql.org/learn/global-object-identification/) specification with the `Node` interface, with their `id: ID!` field representing their unique DID string.

In addition to the `id: ID!` field, the `isViewer: Boolean!` field representing whether the account is the viewer associated to the ComposeDB client are always present, while other fields are generated based on the models present in the composite.

Example [Schema definition](../../guides/data-modeling/schemas.mdx):

```graphql
type Profile @createModel(accountRelation: SINGLE, description: "A basic profile") {
  displayName: String! @string(minLength: 5, maxLength: 100)
}

type Post @createModel(accountRelation: LIST, description: "A simple post") {
  text: String! @string(minLength: 5, maxLength: 100)
}
```

This runtime schema will be generated:

```graphql
# ℹ️ Some types are omitted in this example for brievity

type CeramicAccount implements Node {
  # The following fields are always present
  id: ID!
  isViewer: Boolean!
  # The Post relation is a connection because the Post account relation is LIST
  postList: PostConnection
  # The Post relation is a single object because the Profile account relation is SINGLE
  profile: Profile
}

type Post implements Node {
  id: ID!
  text: String!
}

type PostConnection {
  edges: [PostEdge]
  pageInfo: PageInfo
}

type PostEdge {
  cursor: String
  node: Post
}

type Profile implements Node {
  id: ID!
  displayName: String!
}
```

### `Query` object

The `Query` object represents the root object to perform GraphQL queries, it always contains the following two fields:

- `node(id: ID!): Node`: allowing to access any [Document object](#document-objects) or [DID account](#ceramicaccount-object) using the [GraphQL's `Node` interface](https://graphql.org/learn/global-object-identification/#node-interface).
- `viewer: CeramicAccount`: allowing to access the [`CeramicAccount` object](#ceramicaccount-object) for the DID associated to the ComposeDB client, if set.

In addition to these fields, the ComposeDB runtime will generate connections for all models defined in the composite.

Example [Schema definition](../../guides/data-modeling/schemas.mdx):

```graphql
type Profile @createModel(accountRelation: SINGLE, description: "A basic profile") {
  displayName: String! @string(minLength: 5, maxLength: 100)
}

type Post @createModel(accountRelation: LIST, description: "A simple post") {
  text: String! @string(minLength: 5, maxLength: 100)
}
```

This runtime schema will be generated:

```graphql
# ℹ️ Some types are omitted in this example for brievity

type Query {
  node(id: ID!): Node
  viewer: CeramicAccount
  # ℹ️ Connection arguments are omitted in this example for brievity
  postIndex: PostConnection
  profileIndex: ProfileConnection
}

type CeramicAccount implements Node {
  id: ID!
  isViewer: Boolean!
  postList: PostConnection
  profile: Profile
}

type Post implements Node {
  id: ID!
  text: String!
}

type PostConnection {
  edges: [PostEdge]
  pageInfo: PageInfo
}

type PostEdge {
  cursor: String
  node: Post
}

type Profile implements Node {
  id: ID!
  displayName: String!
}

type ProfileConnection {
  edges: [ProfileEdge]
  pageInfo: PageInfo
}

type ProfileEdge {
  cursor: String
  node: Profile
}
```

## Connections

ComposeDB implements [Relay's Connection specification](https://relay.dev/graphql/connections.htm) to represent one-to-many relationships between nodes ([Document objects](#document-objects) and [DID accounts](#ceramicaccount-object)) in the graph.

Connection objects are generated for all models in the composite, supporting the [Connection arguments](https://relay.dev/graphql/connections.htm#sec-Arguments) and possibly additional arguments for [filtering](#filtering) and [sorting](#sorting) the associated documents.

## Inputs

GraphQL differentiates objects handled in queries from objects used to perform mutations and arguments, using [input types](https://graphql.org/learn/schema/#input-types).

ComposeDB generates input types based on models present in the composite as described below.

### Filtering

- Restrict documents returned in a Connection by content fields
- 2 levels: key/value conditions on document content and nested logical conditions

#### Value conditions

| GraphQL input             | Generated SQL |
| ------------------------- | ------------- |
| isNull: `Boolean`         | IS [NOT] NULL |
| equalTo: `T`              | =             |
| notEqualTo: `T`           | !=            |
| in: `[T]`                 | IN (...)      |
| notIn: `[T]`              | NOT IN (...)  |
| lessThan: `T`             | <             |
| lessThanOrEqualTo: `T`    | <=            |
| greaterThan: `T`          | >             |
| greaterThanOrEqualTo: `T` | >=            |

#### Logical conditions

TODO: `and`, `or` and `not` operators

### Sorting

- Order documents returned in a Connection by content fields

### Document creation

- Content object containing all the required fields
- Create object containing the `content` and `clientMutationId` fields

### Document update

- Partial content object with all fields optional
- UpdateOptions object to set `replace` and/or `version` values
- Update object with `id`, `content`, `options` and `clientMutationId`
