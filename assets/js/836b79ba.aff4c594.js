"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[9108],{54852:(e,t,n)=>{n.d(t,{Zo:()=>p,kt:()=>m});var a=n(49231);function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?r(Object(n),!0).forEach((function(t){i(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,a,i=function(e,t){if(null==e)return{};var n,a,i={},r=Object.keys(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||(i[n]=e[n]);return i}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}var s=a.createContext({}),d=function(e){var t=a.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},p=function(e){var t=d(e.components);return a.createElement(s.Provider,{value:t},e.children)},c="mdxType",u={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},h=a.forwardRef((function(e,t){var n=e.components,i=e.mdxType,r=e.originalType,s=e.parentName,p=l(e,["components","mdxType","originalType","parentName"]),c=d(n),h=i,m=c["".concat(s,".").concat(h)]||c[h]||u[h]||r;return n?a.createElement(m,o(o({ref:t},p),{},{components:n})):a.createElement(m,o({ref:t},p))}));function m(e,t){var n=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var r=n.length,o=new Array(r);o[0]=h;var l={};for(var s in t)hasOwnProperty.call(t,s)&&(l[s]=t[s]);l.originalType=e,l[c]="string"==typeof e?e:i,o[1]=l;for(var d=2;d<r;d++)o[d]=n[d];return a.createElement.apply(null,o)}return a.createElement.apply(null,n)}h.displayName="MDXCreateElement"},84642:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>s,contentTitle:()=>o,default:()=>u,frontMatter:()=>r,metadata:()=>l,toc:()=>d});var a=n(5527),i=(n(49231),n(54852));const r={},o="Verifiable Credentials",l={unversionedId:"verifiable-credentials",id:"verifiable-credentials",title:"Verifiable Credentials",description:"Verifiable Credentials are a W3C standard used by development teams to fulfill a need for tamper-evident claims that can be cryptographically proven to reliably reveal who issued the claim, who (if anyone) is the recipient, the content of the claim itself, and more.",source:"@site/docs/verifiable-credentials.mdx",sourceDirName:".",slug:"/verifiable-credentials",permalink:"/docs/preview/verifiable-credentials",draft:!1,tags:[],version:"current",frontMatter:{}},s={},d=[{value:"But First - What are Verifiable Credentials?",id:"but-first---what-are-verifiable-credentials",level:2},{value:"Where do Verifiable Credentials and Decentralized Storage Converge?",id:"where-do-verifiable-credentials-and-decentralized-storage-converge",level:3},{value:"Getting Started - Key Components",id:"getting-started---key-components",level:2},{value:"Defining Our Schema",id:"defining-our-schema",level:3},{value:"Setting Up Our Veramo Agent",id:"setting-up-our-veramo-agent",level:2},{value:"Install Your Dependencies",id:"install-your-dependencies",level:3},{value:"Environment Variables",id:"environment-variables",level:3},{value:"Generate Veramo DIDs",id:"generate-veramo-dids",level:3},{value:"Generate EIP-712 Signed Verifiable Credentials",id:"generate-eip-712-signed-verifiable-credentials",level:3},{value:"ComposeDB Server and Client Setup",id:"composedb-server-and-client-setup",level:2},{value:"Model Instance Controllers",id:"model-instance-controllers",level:3},{value:"Getting Started",id:"getting-started",level:3},{value:"Interacting with the UI",id:"interacting-with-the-ui",level:3},{value:"Creating JWT Credentials",id:"creating-jwt-credentials",level:3},{value:"Verifying Credentials",id:"verifying-credentials",level:3},{value:"Next Steps",id:"next-steps",level:3}],p={toc:d},c="wrapper";function u(e){let{components:t,...r}=e;return(0,i.kt)(c,(0,a.Z)({},p,r,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"verifiable-credentials"},"Verifiable Credentials"),(0,i.kt)("p",null,"Verifiable Credentials are a W3C standard used by development teams to fulfill a need for tamper-evident claims that can be cryptographically proven to reliably reveal who issued the claim, who (if anyone) is the recipient, the content of the claim itself, and more. "),(0,i.kt)("p",null,"While there are multiple libraries and data model implementations available to developers who want to generate and validate Verifiable Credentials for their applications, this guide outlines one example to help illustrate these general concepts."),(0,i.kt)("h2",{id:"but-first---what-are-verifiable-credentials"},"But First - What are Verifiable Credentials?"),(0,i.kt)("p",null,(0,i.kt)("a",{parentName:"p",href:"https://www.w3.org/TR/vc-data-model/"},"Verifiable Credentials")," offer a digital credentialing format that follows specific ",(0,i.kt)("a",{parentName:"p",href:"https://www.w3.org/"},"World Wide Web Consortium")," open standards. This format relies on several key characteristics that help ensure its reliability as a tamper-proof credential such as including a digital signature that cannot be inauthentically synthesized, the use of Decentralized Identifiers (or DIDs) to represent unique individual identities, and a predictable core data model that allows credential instances to be reconstructed as presentations."),(0,i.kt)("p",null,"Generally speaking, these components break down into three primary categories that make up a Verifiable Credential:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"Metadata"),": This data is often cryptographically signed by the issuer and contains information about the credential itself (such as who the issuer is, when it expires, and so on) in addition to the credential identifier "),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"Claim"),": A set of claims about the credential subject (these must be tamper-proof)"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"Proof"),": A set of properties that allows people to cryptographically verify the source of the data and whether the data has been tampered with")),(0,i.kt)("p",null,"A common use case to point to would be an online education platform that issues credentials when students have completed courses. A Verifiable Credential could be used to reliably show that an issuer (the education platform) attests that a given student (the eventual credential holder) has completed a specific course (included in the metadata). If a graduate student program needed to verify a given credential to accept students, those programs (playing the role of a verifier) would request proofs from the holder and be able to know whether those proofs were valid, invalid, or tampered with."),(0,i.kt)("h3",{id:"where-do-verifiable-credentials-and-decentralized-storage-converge"},"Where do Verifiable Credentials and Decentralized Storage Converge?"),(0,i.kt)("p",null,"Given the data model Verifiable Credentials use, individual credential instances can be stored anywhere - from offline storage on a hard drive, to traditional databases controlled by companies who rely on Verifiable Credentials, to smart contracts on a blockchain, to more performant peer-to-peer storage, and everything in between. Why, then, would developers choose to store verifiable credentials on Ceramic?"),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Data Interoperability")),(0,i.kt)("p",null,"Since Verifiable Credentials are flexible enough to describe a seemingly limitless set of circumstances, yet standardized enough to be able to easily verify the proofs included therein, developers who build on Ceramic not only benefit from the performance and querying capabilities offered by ComposeDB but can also consume verifiable credentials from other issuers and communities built on Ceramic. "),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Self-Sovereign Identity (SSI)")," "),(0,i.kt)("p",null,"Verifiable Credentials contribute to self-sovereign identity in a major way by allowing users to easily prove their identity and share credentials without delegating factors of their identity to some central authority. Developers who allow their users to store their credentials on Ceramic enable their users to retain control and ownership of their data. Since streams in the Ceramic Network can only be modified with the permission of the controller, each credential saved to Ceramic can only be edited or changed in the future by the users themselves. "),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Ease-Of-Querying")),(0,i.kt)("p",null,"While storing raw JSON files to other decentralized storage options like IPFS is always an option, developers who require any layer of storage at scale with the ability to filter, sort, and query data based on more precise qualities will need a storage option that provides functional similarities to a traditional database. This is where ComposeDB comes into play, offering a familiar database experience with native support for GraphQL and automatic performance gains by splitting read/write operations."),(0,i.kt)("p",null,"While the list goes on, let's hop into the guide."),(0,i.kt)("h2",{id:"getting-started---key-components"},"Getting Started - Key Components"),(0,i.kt)("p",null,"To support the functionality we need for our application that uses Verifiable Credentials, we will rely on the following tools:"),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Verifiable Data Registry")),(0,i.kt)("p",null,"One of the key components outlined in the ",(0,i.kt)("a",{parentName:"p",href:"https://www.w3.org/TR/vc-data-model-2.0/#dfn-verifiable-data-registries"},"Verifiable Credential Ecosystem")," is a Verifiable Data Registry. This component is responsible for maintaining things like Verifiable Credential schemas. To fulfill this function, we will be using ",(0,i.kt)("a",{parentName:"p",href:"https://schemas.serto.id/"},"Serto"),", a shared repository of schemas."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Verifiable Credential Library")),(0,i.kt)("p",null,"Our application will also require an open-source library that makes it easy to generate and verify credentials across the various formats needed by our application. For our library, we will use ",(0,i.kt)("a",{parentName:"p",href:"https://veramo.io/"},"Veramo"),"."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Decentralized Storage")),(0,i.kt)("p",null,"Finally, we will be using ComposeDB to both store credentials for our user, as well as retrieve credentials to verify. "),(0,i.kt)("h3",{id:"defining-our-schema"},"Defining Our Schema"),(0,i.kt)("p",null,"If you ",(0,i.kt)("a",{parentName:"p",href:"https://schemas.serto.id/"},"sign up")," for a free account on Serto you'll have the ability to define credential schemas for your uses and applications. However, for our application, we will be using an existing schema definition called ",(0,i.kt)("inlineCode",{parentName:"p"},"Vetted Reviewer")," (see the definition ",(0,i.kt)("a",{parentName:"p",href:"https://schemas.serto.id/schema/vetted-reviewer"},"here"),")."),(0,i.kt)("div",{style:{textAlign:"center"}},(0,i.kt)("p",null,(0,i.kt)("img",{alt:"serto schema",src:n(48794).Z,width:"659",height:"504"}))),(0,i.kt)("p",null,"The basic idea here is that an entity (such as a workplace or group of collaborators) might want to issue ",(0,i.kt)("inlineCode",{parentName:"p"},"Vetted Reviewer")," instances to code reviewers they trust. As you'll notice, the data model is quite simple - we have an identifier for the credential, issuer, and recipient, as well as a date and a simple boolean field indicating whether the subject is or is not trusted. "),(0,i.kt)("p",null,"Serto also supplies a peek view into what the schema would look like in JSON format (though we will later create full instances that we can also inspect):"),(0,i.kt)("div",{style:{textAlign:"center"}},(0,i.kt)("p",null,(0,i.kt)("img",{alt:"serto schema",src:n(32261).Z,width:"729",height:"343"}))),(0,i.kt)("h2",{id:"setting-up-our-veramo-agent"},"Setting Up Our Veramo Agent"),(0,i.kt)("p",null,"Now that we have our schema defined that we'll use for our credentials, we can start setting up the section of our application that uses Veramo. "),(0,i.kt)("p",null,"As outlined in the ",(0,i.kt)("a",{parentName:"p",href:"https://veramo.io/docs/veramo_agent/introduction"},"Veramo Docs"),", our Veramo Agent will act as our application's interface for issuing and verifying credentials, as well as managing a DID that represents the application itself. "),(0,i.kt)("p",null,"We've already done most of this work for you, which we're about to walk through below."),(0,i.kt)("p",null,"To get started, open a new terminal and clone the following repository:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-bash"},"git clone https://github.com/ceramicstudio/verifiable-credentials && cd verifiable-credentials\n")),(0,i.kt)("p",null,"Once you have the repository opened in your text editor of choice, you'll see two sub-directories - one named ",(0,i.kt)("inlineCode",{parentName:"p"},"client")," and the other named ",(0,i.kt)("inlineCode",{parentName:"p"},"express-veramo"),". Let's first explore our ",(0,i.kt)("inlineCode",{parentName:"p"},"express-veramo")," directory. "),(0,i.kt)("p",null,"This section of our application is meant to serve our Veramo Agent on an Express.js server that the ",(0,i.kt)("inlineCode",{parentName:"p"},"client")," section of our application will use to generate and verify credentials. "),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Veramo Agent")),(0,i.kt)("p",null,"If you open ",(0,i.kt)("inlineCode",{parentName:"p"},"/express-veramo/src/veramo/setup.ts")," in your code editor, you can observe how we're instantiating our agent with all of the relevant plugin settings we'll need. For example, we've set our ",(0,i.kt)("inlineCode",{parentName:"p"},"defaultProvider")," (on line 98 within our ",(0,i.kt)("inlineCode",{parentName:"p"},"DIDManager"),' instantiation) to "did:key". We\'ve also enabled the ability to resolve "did:key" DIDs by adding a call to ',(0,i.kt)("inlineCode",{parentName:"p"},"keyDidResolver()")," to our ",(0,i.kt)("inlineCode",{parentName:"p"},"DIDResolverPlugin")," instantiation. Finally, we will be using a local SQLite instance (with TypeORM) to manage our Veramo Agent's DIDs and private keys. "),(0,i.kt)("p",null,"Our agent (with all our custom configurations) will then be available to import and use within each of our methods used to generate DIDs, create credentials, and verify credentials. For example, if you take a look at ",(0,i.kt)("inlineCode",{parentName:"p"},"/express-veramo/src/create-identifier.ts")," you'll see how ",(0,i.kt)("inlineCode",{parentName:"p"},"main")," uses our agent to access the ",(0,i.kt)("inlineCode",{parentName:"p"},"didManagerCreate")," method on the agent's prototype chain."),(0,i.kt)("p",null,"Finally, our ",(0,i.kt)("inlineCode",{parentName:"p"},"/express-veramo/index.ts")," file exposes these agent methods as endpoints for our Express server."),(0,i.kt)("h3",{id:"install-your-dependencies"},"Install Your Dependencies"),(0,i.kt)("p",null,"Install your dependencies from within the ",(0,i.kt)("inlineCode",{parentName:"p"},"/express-veramo")," directory:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-bash"},"yarn install\n")),(0,i.kt)("h3",{id:"environment-variables"},"Environment Variables"),(0,i.kt)("p",null,"You will notice that our Express application will need two environment variables."),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("inlineCode",{parentName:"li"},"INFURA_PROJECT_ID"),": Simply go to ",(0,i.kt)("a",{parentName:"li",href:"https://www.infura.io/"},"infura.io"),' and set up a new Web3 API key. Once set up, you will only need to copy the key itself (it should look something like "b45j76facf05112f9664778z1bf6bd50").'),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("inlineCode",{parentName:"li"},"KMS_SECRET_KEY"),": You can generate a KMS Secret Key using the Veramo CLI:")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-bash"},"npx @veramo/cli config create-secret-key\n")),(0,i.kt)("h3",{id:"generate-veramo-dids"},"Generate Veramo DIDs"),(0,i.kt)("p",null,"We will also need to generate an admin DID that our Veramo Agent will use when generating credentials. This can be thought of as the admin seed representing our application:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-bash"},"yarn ts-node --esm ./src/create-identifier.ts\n")),(0,i.kt)("p",null,"We are now ready to start up our Express server! To begin, run the following in your terminal:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-bash"},"yarn start\n")),(0,i.kt)("p",null,"If all is successful so far, you should see the following in your terminal logs:"),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"server started at http://localhost:8080")),(0,i.kt)("h3",{id:"generate-eip-712-signed-verifiable-credentials"},"Generate EIP-712 Signed Verifiable Credentials"),(0,i.kt)("p",null,"The ",(0,i.kt)("a",{parentName:"p",href:"https://eips.ethereum.org/EIPS/eip-712"},"EIP712")," standard allows wallets to display data in signing prompts in a readable and highly structured format and also happens to be a standard supported by Veramo's modular plugins. Unlike other formats, EIP712 requires ",(0,i.kt)("inlineCode",{parentName:"p"},"TypedData")," (a JSON object containing type information, as well as domain separator parameters and the message). "),(0,i.kt)("p",null,"If you observe ",(0,i.kt)("inlineCode",{parentName:"p"},"/express-veramo/src/create-credential-712.ts")," you'll notice that it looks almost identical to ",(0,i.kt)("inlineCode",{parentName:"p"},"/express-veramo/src/create-credential-jws.ts"),'. However, one major factor that will yield a very different output is the value for the "proofFormat" field (we use ',(0,i.kt)("inlineCode",{parentName:"p"},"EthereumEip712Signature2021")," for our EIP712 instance)."),(0,i.kt)("p",null,"You'll also notice that the body of our credential references the schema we defined in Serto earlier, as well as the actual subject of the credential (indicating the recipient's identifier and whether they are trusted)."),(0,i.kt)("p",null,"In ",(0,i.kt)("inlineCode",{parentName:"p"},"/express-veramo/index.ts")," you'll see that we're exposing this method on our /create endpoint. "),(0,i.kt)("p",null,'If you have Postman, you can open up a window and send a POST request to "http://localhost:8080/create" using a dummy input DID:'),(0,i.kt)("div",{style:{textAlign:"center"}},(0,i.kt)("p",null,(0,i.kt)("img",{alt:"postman query",src:n(58030).Z,width:"1836",height:"514"}))),(0,i.kt)("p",null,"You'll be able to view the output thereafter, which should look similar to this:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-json"},'{\n    "issuer": "did:key:zQ3shjSvqxWu82TG8ARw6yZYvRhnAxi3MrDS7MoghVJLrUh1h",\n    "@context": [\n        "https://www.w3.org/2018/credentials/v1",\n        "https://beta.api.schemas.serto.id/v1/public/vetted-reviewer/1.0/ld-context.json"\n    ],\n    "type": [\n        "VerifiableCredential",\n        "VettedReviewer"\n    ],\n    "credentialSchema": {\n        "id": "https://beta.api.schemas.serto.id/v1/public/vetted-reviewer/1.0/json-schema.json",\n        "type": "JsonSchemaValidator2018"\n    },\n    "issuanceDate": "2023-10-24T22:10:31.906Z",\n    "credentialSubject": {\n        "isTrusted": true,\n        "id": "did:pkh:eip155:1:0xc362c16a0dcbea78fb03a8f97f56deea905617bb"\n    },\n    "proof": {\n        "verificationMethod": "did:key:zQ3shjSvqxWu82TG8ARw6yZYvRhnAxi3MrDS7MoghVJLrUh1h#zQ3shjSvqxWu82TG8ARw6yZYvRhnAxi3MrDS7MoghVJLrUh1h",\n        "created": "2023-10-24T22:10:31.906Z",\n        "proofPurpose": "assertionMethod",\n        "type": "EthereumEip712Signature2021",\n        "proofValue": "0xa090c41ba3a768ddf2695000ddc98009bf7dcddf9778e9d54cefcd3adbd7faaf08d4f2e9b31038112221a2d8dddbc1b0024488ea3b926400b767d1fc1ea4309b1b",\n        "eip712": {\n            "domain": {\n                "chainId": 1,\n                "name": "VerifiableCredential",\n                "version": "1"\n            },\n            "types": {\n                "EIP712Domain": [\n                    {\n                        "name": "name",\n                        "type": "string"\n                    },\n                    {\n                        "name": "version",\n                        "type": "string"\n                    },\n                    {\n                        "name": "chainId",\n                        "type": "uint256"\n                    }\n                ],\n                "CredentialSchema": [\n                    {\n                        "name": "id",\n                        "type": "string"\n                    },\n                    {\n                        "name": "type",\n                        "type": "string"\n                    }\n                ],\n                "CredentialSubject": [\n                    {\n                        "name": "id",\n                        "type": "string"\n                    },\n                    {\n                        "name": "isTrusted",\n                        "type": "bool"\n                    }\n                ],\n                "Proof": [\n                    {\n                        "name": "created",\n                        "type": "string"\n                    },\n                    {\n                        "name": "proofPurpose",\n                        "type": "string"\n                    },\n                    {\n                        "name": "type",\n                        "type": "string"\n                    },\n                    {\n                        "name": "verificationMethod",\n                        "type": "string"\n                    }\n                ],\n                "VerifiableCredential": [\n                    {\n                        "name": "@context",\n                        "type": "string[]"\n                    },\n                    {\n                        "name": "credentialSchema",\n                        "type": "CredentialSchema"\n                    },\n                    {\n                        "name": "credentialSubject",\n                        "type": "CredentialSubject"\n                    },\n                    {\n                        "name": "issuanceDate",\n                        "type": "string"\n                    },\n                    {\n                        "name": "issuer",\n                        "type": "string"\n                    },\n                    {\n                        "name": "proof",\n                        "type": "Proof"\n                    },\n                    {\n                        "name": "type",\n                        "type": "string[]"\n                    }\n                ]\n            },\n            "primaryType": "VerifiableCredential"\n        }\n    }\n}\n')),(0,i.kt)("p",null,"Notice how the ",(0,i.kt)("inlineCode",{parentName:"p"},"proof")," key in our JSON output includes both a ",(0,i.kt)("inlineCode",{parentName:"p"},"proofValue")," as well as all of the ",(0,i.kt)("inlineCode",{parentName:"p"},"TypedData")," details required for the EIP712 format. "),(0,i.kt)("p",null,"If you send the same post request to the /create-jws endpoint, you will notice how the JSON web token output differs significantly:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-json"},'{\n    "credentialSubject": {\n        "isTrusted": true,\n        "id": "did:pkh:eip155:1:0xc362c16a0dcbea78fb03a8f97f56deea905617bb"\n    },\n    "issuer": {\n        "id": "did:key:z6MkrmuQWoiVynAchQiuVwrv8nt6dU3equSFJ3ZnuSnjhnkp"\n    },\n    "type": [\n        "VerifiableCredential",\n        "VettedReviewer"\n    ],\n    "credentialSchema": {\n        "id": "https://beta.api.schemas.serto.id/v1/public/vetted-reviewer/1.0/json-schema.json",\n        "type": "JsonSchemaValidator2018"\n    },\n    "@context": [\n        "https://www.w3.org/2018/credentials/v1",\n        "https://beta.api.schemas.serto.id/v1/public/vetted-reviewer/1.0/ld-context.json"\n    ],\n    "issuanceDate": "2023-10-24T22:14:09.000Z",\n    "proof": {\n        "type": "JwtProof2020",\n        "jwt": "eyJhbGciOiJFZERTQSIsInR5cCI6IkpXVCJ9.eyJ2YyI6eyJAY29udGV4dCI6WyJodHRwczovL3d3dy53My5vcmcvMjAxOC9jcmVkZW50aWFscy92MSIsImh0dHBzOi8vYmV0YS5hcGkuc2NoZW1hcy5zZXJ0by5pZC92MS9wdWJsaWMvdmV0dGVkLXJldmlld2VyLzEuMC9sZC1jb250ZXh0Lmpzb24iXSwidHlwZSI6WyJWZXJpZmlhYmxlQ3JlZGVudGlhbCIsIlZldHRlZFJldmlld2VyIl0sImNyZWRlbnRpYWxTdWJqZWN0Ijp7ImlzVHJ1c3RlZCI6dHJ1ZX0sImNyZWRlbnRpYWxTY2hlbWEiOnsiaWQiOiJodHRwczovL2JldGEuYXBpLnNjaGVtYXMuc2VydG8uaWQvdjEvcHVibGljL3ZldHRlZC1yZXZpZXdlci8xLjAvanNvbi1zY2hlbWEuanNvbiIsInR5cGUiOiJKc29uU2NoZW1hVmFsaWRhdG9yMjAxOCJ9fSwic3ViIjoiZGlkOnBraDplaXAxNTU6MToweGMzNjJjMTZhMGRjYmVhNzhmYjAzYThmOTdmNTZkZWVhOTA1NjE3YmIiLCJuYmYiOjE2OTgxODU2NDksImlzcyI6ImRpZDprZXk6ejZNa3JtdVFXb2lWeW5BY2hRaXVWd3J2OG50NmRVM2VxdVNGSjNabnVTbmpobmtwIn0.rAhjw1_bkvY9QNSTJsoWHnsYU4ccYHngJ36x6gv567DEp85QGpz3zcKbrJAIBEdvR76C5-FcF6tSKk6TnhiADQ"\n    }\n}\n')),(0,i.kt)("p",null,"While both versions can be reliably stored and later verified, the JWT implementation compacts all of the necessary credential data and signatures into a single field. "),(0,i.kt)("p",null,"For this guide, we will show you how to store both JWT and EIP712 Verifiable Credentials on ComposeDB, and later how to reconstruct and verify them using our Veramo agent. "),(0,i.kt)("h2",{id:"composedb-server-and-client-setup"},"ComposeDB Server and Client Setup"),(0,i.kt)("p",null,"You can leave your Express server running as we begin exploring the ",(0,i.kt)("inlineCode",{parentName:"p"},"client")," section of the application, starting with the data models we'll need for storing our Verifiable Credentials."),(0,i.kt)("p",null,"If you open your ",(0,i.kt)("inlineCode",{parentName:"p"},"/client/composites")," directory in your text editor, you'll find two schema definitions that represent our EIP712 and JWT formats:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-graphql"},'# 00-verifiableCredential.graphql \n\ntype VerifiableCredential\n  @createModel(accountRelation: LIST, description: "A verifiable credential")\n  @createIndex(fields: [{ path: "context" }])\n  @createIndex(fields: [{ path: "issuanceDate" }]) {\n  controller: DID! @documentAccount\n  issuer: DID! @accountReference\n  context: [String!]! @string(maxLength: 1000) @list(maxLength: 100)\n  type: [String!]! @string(maxLength: 1000) @list(maxLength: 100)\n  credentialSchema: CredentialSchema!\n  issuanceDate: DateTime!\n  credentialSubject: CredentialSubject!\n  proof: Proof!\n}\n\ntype Types {\n  name: String! @string(maxLength: 100)\n  type: String! @string(maxLength: 100)\n}\n\ntype CredentialSchema {\n  id: String! @string(maxLength: 1000)\n  type: String! @string(maxLength: 1000)\n}\n\ntype CredentialSubject {\n  id: DID! @accountReference\n  isTrusted: Boolean!\n}\n\ntype Proof {\n  verificationMethod: String! @string(maxLength: 1000)\n  created: DateTime! \n  proofPurpose: String! @string(maxLength: 1000)\n  type: String! @string(maxLength: 1000)\n  proofValue: String! @string(maxLength: 1000)\n  eip712: EIP712!\n}\n\ntype EIP712 {\n    domain: Domain! \n    types: ProofTypes!\n    primaryType: String! @string(maxLength: 100)\n}\n\ntype ProofTypes {\n    EIP712Domain: [Types!]! @list(maxLength: 100)\n    CredentialSchema: [Types!]! @list(maxLength: 100)\n    CredentialSubject: [Types!]! @list(maxLength: 100)\n    Proof: [Types!]! @list(maxLength: 100)\n    VerifiableCredential: [Types!]! @list(maxLength: 100)\n}\n\ntype Domain {\n  chainId: Int!\n  name: String! @string(maxLength: 100)\n  version: String! @string(maxLength: 100)\n}\n')),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-graphql"},'# 01-verifiableCredentialJwt.graphql\n\ntype VerifiableCredentialJWS\n  @createModel(accountRelation: LIST, description: "A verifiable credential")\n  @createIndex(fields: [{ path: "context" }])\n  @createIndex(fields: [{ path: "issuanceDate" }]) {\n  controller: DID! @documentAccount\n  issuer: DID! @accountReference\n  context: [String!]! @string(maxLength: 1000) @list(maxLength: 100)\n  type: [String!]! @string(maxLength: 1000) @list(maxLength: 100)\n  credentialSchema: CredentialSchema!\n  issuanceDate: DateTime!\n  credentialSubject: CredentialSubject!\n  proof: Proof!\n}\n\ntype Types {\n  name: String! @string(maxLength: 100)\n  type: String! @string(maxLength: 100)\n}\n\ntype CredentialSchema {\n  id: String! @string(maxLength: 1000)\n  type: String! @string(maxLength: 1000)\n}\n\ntype CredentialSubject {\n  id: DID! @accountReference\n  isTrusted: Boolean!\n}\n\ntype Proof {\n  type: String! @string(maxLength: 1000)\n  jwt: String! @string(maxLength: 100000)\n}\n')),(0,i.kt)("p",null,"Similar to the difference in the returned data we observed when hitting our two ",(0,i.kt)("inlineCode",{parentName:"p"},"create")," endpoints in our Express application, you'll immediately notice that the primary divergence in the way we're storing our credentials in ComposeDB comes down to the ",(0,i.kt)("inlineCode",{parentName:"p"},"proof")," field. While the ",(0,i.kt)("inlineCode",{parentName:"p"},"Proof")," type used by our EIP712 credential contains multiple layers of nested objects, our JWT implementation only contains one layer (given that the information needed to later verify the credential is saved to the ",(0,i.kt)("inlineCode",{parentName:"p"},"jwt")," field). "),(0,i.kt)("h3",{id:"model-instance-controllers"},"Model Instance Controllers"),(0,i.kt)("p",null,"This example application was also intentionally set up to display two different ways a development team might choose to implement model instance ownership. More specifically, it may make sense (under certain situations) for the application itself to have the exclusive ability to change model instance documents after they are created. Conversely, as mentioned toward the beginning of this guide, developers may instead allow their users to retain control of each credential instance (since they know that it would be easy to tell whether a credential has been tampered with anyway)."),(0,i.kt)("p",null,"The dummy UI entails two pages found at ",(0,i.kt)("inlineCode",{parentName:"p"},"/client/src/pages/index.tsx")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"/client/src/pages/jwt.tsx")," which respectively use the components found at ",(0,i.kt)("inlineCode",{parentName:"p"},"/client/src/components/VC712.tsx")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"/client/src/components/VCJwt.tsx"),". You'll notice how the VC712 component calls an API within the ",(0,i.kt)("inlineCode",{parentName:"p"},"createCredential")," method found at ",(0,i.kt)("inlineCode",{parentName:"p"},"/api/create")," (after obtaining an EIP712 Verifiable Credential from our Express server). "),(0,i.kt)("p",null,"If you take a look into ",(0,i.kt)("inlineCode",{parentName:"p"},"/client/src/pages/api/create.ts"),", you'll find the corresponding route definition. Notice how we call an ",(0,i.kt)("inlineCode",{parentName:"p"},"authenticateDID")," method before running a mutation query to authenticate a static seed environment variable (which represents our application's DID). "),(0,i.kt)("p",null,"Conversely, you'll notice how the ",(0,i.kt)("inlineCode",{parentName:"p"},"createCredential")," method within our ",(0,i.kt)("inlineCode",{parentName:"p"},"/client/src/components/VCJwt.tsx")," component executes a mutation query on our ",(0,i.kt)("inlineCode",{parentName:"p"},"compose")," instance. If you dig a bit deeper, you'll notice that we (as the individual user) are already authenticated on the ",(0,i.kt)("inlineCode",{parentName:"p"},"ComposeClient")," instance (imported from ",(0,i.kt)("inlineCode",{parentName:"p"},"/client/src/fragments/index.tsx"),"). "),(0,i.kt)("h3",{id:"getting-started"},"Getting Started"),(0,i.kt)("p",null,"To get started in the client section, we'll first have to install our dependencies (be sure to cd into your ",(0,i.kt)("inlineCode",{parentName:"p"},"client")," directory):"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-bash"},"yarn install\n")),(0,i.kt)("p",null,"Next, we will need to generate an admin seed and ComposeDB configuration our application will use. This example repository contains a script found at ",(0,i.kt)("inlineCode",{parentName:"p"},"/client/scripts/commands/mjs"),' that generates one for you (preset to run "inmemory" which is ideal for testing).'),(0,i.kt)("p",null,"To generate your necessary credentials, run the following in your terminal:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-bash"},"yarn generate\n")),(0,i.kt)("p",null,"Finally, you will need to create a .env file with a SECRET_KEY - this is what our ",(0,i.kt)("inlineCode",{parentName:"p"},"/client/src/pages/api/create")," route will use to authenticate us as the developer on our ComposeClient instance (this must be 32 bytes and must be different from our admin_seed.txt). "),(0,i.kt)("p",null,"Feel free to copy-paste this dummy seed into your .env file:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-bash"},'SECRET_KEY="11b574d316903ced6cc3f4787bbcc3047d9c72d1da4d83e36fe714ef7891jb50"\n')),(0,i.kt)("p",null,"Finally, go ahead and start your application in development mode (switch to node v16 first):"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-bash"},"nvm use 16\nyarn dev\n")),(0,i.kt)("h3",{id:"interacting-with-the-ui"},"Interacting with the UI"),(0,i.kt)("p",null,"If you have been following along up until this point, you should be able to access the UI in your browser on port 3000. Go ahead and connect your wallet using the Web3Modal:"),(0,i.kt)("div",{style:{textAlign:"center"}},(0,i.kt)("p",null,(0,i.kt)("img",{alt:"verifiable credential playground",src:n(18748).Z,width:"1356",height:"1010"}))),(0,i.kt)("p",null,"While our UI in this context does not illustrate a setup that would be used in production, readers following this guide should imagine an application's flow whereby users log in, exhibit behavior by performing tasks, and receive verifiable credentials signed by the application. "),(0,i.kt)("p",null,"In our case, we're mimicking this behavior with the simple push of a button, which you'll see after logging in:"),(0,i.kt)("div",{style:{textAlign:"center"}},(0,i.kt)("p",null,(0,i.kt)("img",{alt:"generate 712 credentials",src:n(23181).Z,width:"1610",height:"993"}))),(0,i.kt)("p",null,"Jumping back to your text editor, you'll see how the ",(0,i.kt)("inlineCode",{parentName:"p"},"Generate Verifiable Credential")," button click is tied to the ",(0,i.kt)("inlineCode",{parentName:"p"},"createCredential")," method found in ",(0,i.kt)("inlineCode",{parentName:"p"},"/client/src/components/VC712.tsx"),". This method then sends a fetch request to our Express server running on port 8080 with the ",(0,i.kt)("inlineCode",{parentName:"p"},"/create")," route, thus invoking a response from the corresponding ",(0,i.kt)("inlineCode",{parentName:"p"},"createCredential")," method at ",(0,i.kt)("inlineCode",{parentName:"p"},"/express-veramo/src/create-credential-712.ts"),". You'll also notice how we're sending over our user's \"did:pkh\" DID (which we saved in our local storage for easy access) to be used for the ",(0,i.kt)("inlineCode",{parentName:"p"},"id")," field in our ",(0,i.kt)("inlineCode",{parentName:"p"},"credentialSubject")," key within our credential."),(0,i.kt)("p",null,"Finally, back in our React component, you'll see how we use the result of this fetch request to hit our endpoint at ",(0,i.kt)("inlineCode",{parentName:"p"},"/api/create"),", which generates a model instance document using our application as the controller DID (which we discussed above)."),(0,i.kt)("p",null,"Go ahead and click ",(0,i.kt)("inlineCode",{parentName:"p"},"Generate Verifiable Credential")," to see this in action."),(0,i.kt)("div",{style:{textAlign:"center"}},(0,i.kt)("p",null,(0,i.kt)("img",{alt:"eip712 generate",src:n(96242).Z,width:"1524",height:"1266"}))),(0,i.kt)("p",null,'If you generated a few dummy credentials using Postman in the previous section, you\'ll notice that the output looks the same. You should also now see your own "did:pkh" appear within the ',(0,i.kt)("inlineCode",{parentName:"p"},"credentialSubject")," key."),(0,i.kt)("h3",{id:"creating-jwt-credentials"},"Creating JWT Credentials"),(0,i.kt)("p",null,"If you navigate to ",(0,i.kt)("inlineCode",{parentName:"p"},"localhost:3000/jwt")," in your browser, you will be able to generate credentials using JWTs (and with yourself, the user, as the model instance controller in ComposeDB):"),(0,i.kt)("div",{style:{textAlign:"center"}},(0,i.kt)("p",null,(0,i.kt)("img",{alt:"jwt generate",src:n(56422).Z,width:"1559",height:"1192"}))),(0,i.kt)("h3",{id:"verifying-credentials"},"Verifying Credentials"),(0,i.kt)("p",null,"One item we haven't yet discussed is the process of verifying credentials. Given how this process entails querying ComposeDB and reconstructing a credential instance for verification, we should also discuss what changes we had to make between the original credential output from Veramo and the saved result in ComposeDB."),(0,i.kt)("p",null,'You\'ll notice that both of our ComposeDB schema definitions save the entirety of the Veramo credential output except for changing the name of the "@context" key to "context" (given field naming constraints in GraphQL). We therefore replace the name of this key with "context" when running our mutation query, but must also reconstruct it when querying ComposeDB and reconstructing our credential.'),(0,i.kt)("p",null,"Given that you're already on the ",(0,i.kt)("inlineCode",{parentName:"p"},"localhost:3000/jwt")," page, we'll jump into its corresponding component at ",(0,i.kt)("inlineCode",{parentName:"p"},"/client/src/components/VCJwt.tsx"),". You'll notice how our ",(0,i.kt)("inlineCode",{parentName:"p"},"verifyCredential")," method (tied to the ",(0,i.kt)("inlineCode",{parentName:"p"},"Verify JWT Credential")," button) adds an ",(0,i.kt)("inlineCode",{parentName:"p"},"@context")," key-value pair to our ",(0,i.kt)("inlineCode",{parentName:"p"},"final")," object (and deleting the ",(0,i.kt)("inlineCode",{parentName:"p"},"context")," pair) before hitting our Express server at ",(0,i.kt)("inlineCode",{parentName:"p"},"/verify-jws"),"."),(0,i.kt)("p",null,"If you take a look at ",(0,i.kt)("inlineCode",{parentName:"p"},"/express-veramo/src/verify-credential-jws.ts")," you'll see how we deconstruct our payload during the verification process (you can also see how this is done for our EIP712 verification route at ",(0,i.kt)("inlineCode",{parentName:"p"},"/express-veramo/src/verify-credential-712.ts"),")."),(0,i.kt)("p",null,'Go ahead and click "Verify JWT Credential" if you still have ',(0,i.kt)("inlineCode",{parentName:"p"},"localhost:3000/jwt")," open in your browser:"),(0,i.kt)("div",{style:{textAlign:"center"}},(0,i.kt)("p",null,(0,i.kt)("img",{alt:"jwt verify",src:n(87339).Z,width:"1473",height:"1268"}))),(0,i.kt)("p",null,"Back in our ",(0,i.kt)("inlineCode",{parentName:"p"},"/client/src/components/VCJwt")," component you'll notice that we first make a fetch request to ",(0,i.kt)("inlineCode",{parentName:"p"},"/api/query-jws")," route (found at ",(0,i.kt)("inlineCode",{parentName:"p"},"/client/src/pages/api/query-jws"),") to grab the most recent ",(0,i.kt)("inlineCode",{parentName:"p"},"VerifiableCredentialJWS")," instance from our ComposeClient. Note that in a production setting when dealing with multiple users and many instance documents, your query might instead filter based on the user's DID."),(0,i.kt)("p",null,"Finally, our ",(0,i.kt)("inlineCode",{parentName:"p"},"VCJwt")," component then hits our ",(0,i.kt)("inlineCode",{parentName:"p"},"verify-jws")," Express endpoint we just discussed to retrieve a response from our Veramo agent."),(0,i.kt)("h3",{id:"next-steps"},"Next Steps"),(0,i.kt)("p",null,"We hope you've enjoyed this example implementation of using ComposeDB to save and retrieve Verifiable Credentials. However, you may be wondering what else is possible in the realm of verifiable claims, or you may have a need to allow your users to encrypt their claims when saving to Ceramic."),(0,i.kt)("p",null,"Here are a few resources you might find useful as you continue to discover what's possible with ComposeDB:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://docs.attest.sh/docs/tutorials/ceramic-storage"},(0,i.kt)("strong",{parentName:"a"},"Creating Attestations with EAS")),' - Learn how to use the Ethereum Attestation Service to generate a different class of verifiable claims called "Attestations". '),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://developer.litprotocol.com/v3/integrations/storage/ceramic-example"},(0,i.kt)("strong",{parentName:"a"},"Lit Protocol with ComposeDB"))," - Follow a tutorial that shows how to use Lit Protocol for access control together with ComposeDB."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://blog.ceramic.network/tutorial-encrypted-data-on-composedb/"},(0,i.kt)("strong",{parentName:"a"},"Encrypted Data on ComposeDB"))," - Learn yet another way to encrypt and decrypt data on ComposeDB by generating an ",(0,i.kt)("inlineCode",{parentName:"li"},"encryptionDid")," instance.")))}u.isMDXComponent=!0},96242:(e,t,n)=>{n.d(t,{Z:()=>a});const a=n.p+"assets/images/eip-712-generate-cfe0aae5db3bcefbf35f854f135068cc.png"},23181:(e,t,n)=>{n.d(t,{Z:()=>a});const a=n.p+"assets/images/generate-712-3f57df630cd8e8308705e8ca9bf42116.png"},56422:(e,t,n)=>{n.d(t,{Z:()=>a});const a=n.p+"assets/images/jwt-generate-b6d6f9fcce692733a8b5662dd478aa90.png"},58030:(e,t,n)=>{n.d(t,{Z:()=>a});const a=n.p+"assets/images/postman-5c59090186d1ee69fd3963acd22224db.png"},48794:(e,t,n)=>{n.d(t,{Z:()=>a});const a=n.p+"assets/images/schema_serto-9575b913dfb77f2f8fcdeb2ab3152db3.png"},32261:(e,t,n)=>{n.d(t,{Z:()=>a});const a=n.p+"assets/images/serto-example-27bf55dbafeee319aaacf5f90accad43.png"},18748:(e,t,n)=>{n.d(t,{Z:()=>a});const a=n.p+"assets/images/vc-playground-203450ed0ae34dd4d24b836ee85e9f4f.png"},87339:(e,t,n)=>{n.d(t,{Z:()=>a});const a=n.p+"assets/images/verify-jwt-6ebb14debfb2e83ff8dea7a509f94bec.png"}}]);