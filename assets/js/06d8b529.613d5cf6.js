"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[9091],{4852:(e,t,r)=>{r.d(t,{Zo:()=>d,kt:()=>m});var a=r(9231);function n(e,t,r){return t in e?Object.defineProperty(e,t,{value:r,enumerable:!0,configurable:!0,writable:!0}):e[t]=r,e}function o(e,t){var r=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),r.push.apply(r,a)}return r}function i(e){for(var t=1;t<arguments.length;t++){var r=null!=arguments[t]?arguments[t]:{};t%2?o(Object(r),!0).forEach((function(t){n(e,t,r[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(r)):o(Object(r)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(r,t))}))}return e}function s(e,t){if(null==e)return{};var r,a,n=function(e,t){if(null==e)return{};var r,a,n={},o=Object.keys(e);for(a=0;a<o.length;a++)r=o[a],t.indexOf(r)>=0||(n[r]=e[r]);return n}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)r=o[a],t.indexOf(r)>=0||Object.prototype.propertyIsEnumerable.call(e,r)&&(n[r]=e[r])}return n}var c=a.createContext({}),l=function(e){var t=a.useContext(c),r=t;return e&&(r="function"==typeof e?e(t):i(i({},t),e)),r},d=function(e){var t=l(e.components);return a.createElement(c.Provider,{value:t},e.children)},p={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},u=a.forwardRef((function(e,t){var r=e.components,n=e.mdxType,o=e.originalType,c=e.parentName,d=s(e,["components","mdxType","originalType","parentName"]),u=l(r),m=n,b=u["".concat(c,".").concat(m)]||u[m]||p[m]||o;return r?a.createElement(b,i(i({ref:t},d),{},{components:r})):a.createElement(b,i({ref:t},d))}));function m(e,t){var r=arguments,n=t&&t.mdxType;if("string"==typeof e||n){var o=r.length,i=new Array(o);i[0]=u;var s={};for(var c in t)hasOwnProperty.call(t,c)&&(s[c]=t[c]);s.originalType=e,s.mdxType="string"==typeof e?e:n,i[1]=s;for(var l=2;l<o;l++)i[l]=r[l];return a.createElement.apply(null,i)}return a.createElement.apply(null,r)}u.displayName="MDXCreateElement"},25:(e,t,r)=>{r.r(t),r.d(t,{assets:()=>c,contentTitle:()=>i,default:()=>p,frontMatter:()=>o,metadata:()=>s,toc:()=>l});var a=r(9675),n=(r(9231),r(4852));const o={},i="Database",s={unversionedId:"database",id:"database",title:"Database",description:"Ceramic Server",source:"@site/docs/database.mdx",sourceDirName:".",slug:"/database",permalink:"/docs/preview/database",draft:!1,tags:[],version:"current",frontMatter:{},sidebar:"docs",previous:{title:"Data Modeling Concepts",permalink:"/docs/preview/data-modeling-concepts"},next:{title:"Community",permalink:"/docs/preview/community"}},c={},l=[{value:"Ceramic Server",id:"ceramic-server",level:2},{value:"GraphQL Client",id:"graphql-client",level:2}],d={toc:l};function p(e){let{components:t,...r}=e;return(0,n.kt)("wrapper",(0,a.Z)({},d,r,{components:t,mdxType:"MDXLayout"}),(0,n.kt)("h1",{id:"database"},"Database"),(0,n.kt)("h2",{id:"ceramic-server"},"Ceramic Server"),(0,n.kt)("p",null,"Building a decentralized graph database is a bit different than building a centralized one. As a result, there are a few important changes required when running a JS Ceramic node after the ComposeDB release. "),(0,n.kt)("p",null,"Every node must now be backed by a SQL database, SQLite or Postgres, that will be used to index the data and construct the database for the models in your composite. Each node decides what to index and store in the database based on the models contained in the composite, which must be passed to the node during development."),(0,n.kt)("p",null,"Ceramic acts as a syncing protocol that maintains your local database state against a global network of documents and interoperable models, maintained via the same verifiable event streams that have always been at the core of Ceramic\u2014allowing you to trust the integrity of your index."),(0,n.kt)("h2",{id:"graphql-client"},"GraphQL Client"),(0,n.kt)("p",null,"Developers now only need to use one library, the ComposeDB Client, which provides a GraphQL interface to Ceramic. This client needs to be passed a composite in order to saturate its own APIs and know which models you\u2019re using. Once your ComposeDB Client is loaded with your composite, you can make GraphQL queries and mutations against your Ceramic node. Using ComposeDB will be much easier and more streamlined than building directly with previous developer packages on Ceramic\u2014such as IDX or DID DataStore."))}p.isMDXComponent=!0}}]);