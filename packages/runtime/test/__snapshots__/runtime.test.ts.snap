// Jest Snapshot v1, https://goo.gl/fbAQLP

exports[`runtime SET account relation support 1`] = `
"type Query {
  """Fetches objects given their IDs"""
  nodes(
    """The IDs of objects"""
    ids: [ID!]!
  ): [Node]!

  """Fetches an object given its ID"""
  node(
    """The ID of an object"""
    id: ID!
  ): Node

  """Account currently authenticated on the Ceramic instance, if set"""
  viewer: CeramicAccount
  favoriteIndex(
    """Returns the items in the list that come after the specified cursor."""
    after: String

    """Returns the first n items from the list."""
    first: Int

    """Returns the items in the list that come before the specified cursor."""
    before: String

    """Returns the last n items from the list."""
    last: Int
  ): FavoriteConnection
  favoriteCount: Int!
  postIndex(
    """Returns the items in the list that come after the specified cursor."""
    after: String

    """Returns the first n items from the list."""
    first: Int

    """Returns the items in the list that come before the specified cursor."""
    before: String

    """Returns the last n items from the list."""
    last: Int
    filters: PostFiltersInput
    sorting: PostSortingInput
  ): PostConnection
  postCount(filters: PostFiltersInput): Int!
  commentIndex(
    """Returns the items in the list that come after the specified cursor."""
    after: String

    """Returns the first n items from the list."""
    first: Int

    """Returns the items in the list that come before the specified cursor."""
    before: String

    """Returns the last n items from the list."""
    last: Int
    filters: CommentFiltersInput
    sorting: CommentSortingInput
  ): CommentConnection
  commentCount(filters: CommentFiltersInput): Int!
}

"""An object with an ID"""
interface Node {
  """The id of the object."""
  id: ID!
}

type CeramicAccount implements Node {
  """Globally unique identifier of the account (DID string)"""
  id: ID!

  """
  Whether the Ceramic instance is currently authenticated with this account or not
  """
  isViewer: Boolean!
  favorite(with: WithFavoriteInput!): Favorite
  favoriteList(
    """Returns the items in the list that come after the specified cursor."""
    after: String

    """Returns the first n items from the list."""
    first: Int

    """Returns the items in the list that come before the specified cursor."""
    before: String

    """Returns the last n items from the list."""
    last: Int
  ): FavoriteConnection
  favoriteListCount: Int!
  postList(
    """Returns the items in the list that come after the specified cursor."""
    after: String

    """Returns the first n items from the list."""
    first: Int

    """Returns the items in the list that come before the specified cursor."""
    before: String

    """Returns the last n items from the list."""
    last: Int
    filters: PostFiltersInput
    sorting: PostSortingInput
  ): PostConnection
  postListCount(filters: PostFiltersInput): Int!
  commentList(
    """Returns the items in the list that come after the specified cursor."""
    after: String

    """Returns the first n items from the list."""
    first: Int

    """Returns the items in the list that come before the specified cursor."""
    before: String

    """Returns the last n items from the list."""
    last: Int
    filters: CommentFiltersInput
    sorting: CommentSortingInput
  ): CommentConnection
  commentListCount(filters: CommentFiltersInput): Int!
}

type Favorite implements Node {
  id: ID!
  tag: String!
  note: String
  docID: CeramicStreamID!
  doc: Node
}

"""A Ceramic Stream ID"""
scalar CeramicStreamID @specifiedBy(url: "https://cips.ceramic.network/CIPs/cip-59#streamid")

input WithFavoriteInput {
  docID: CeramicStreamID!
  tag: String!
}

"""A connection to a list of items."""
type FavoriteConnection {
  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """A list of edges."""
  edges: [FavoriteEdge]
}

"""Information about pagination in a connection."""
type PageInfo {
  """When paginating forwards, are there more items?"""
  hasNextPage: Boolean!

  """When paginating backwards, are there more items?"""
  hasPreviousPage: Boolean!

  """When paginating backwards, the cursor to continue."""
  startCursor: String

  """When paginating forwards, the cursor to continue."""
  endCursor: String
}

"""An edge in a connection."""
type FavoriteEdge {
  """The item at the end of the edge"""
  node: Favorite

  """A cursor for use in pagination"""
  cursor: String!
}

"""A connection to a list of items."""
type PostConnection {
  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """A list of edges."""
  edges: [PostEdge]
}

"""An edge in a connection."""
type PostEdge {
  """The item at the end of the edge"""
  node: Post

  """A cursor for use in pagination"""
  cursor: String!
}

type Post implements Node {
  id: ID!
  date: DateTime
  text: String!
  title: String!

  """Account controlling the document"""
  author: CeramicAccount!

  """Current version of the document"""
  version: CeramicCommitID!
  commentsCount(
    """Counts only documents created by the provided account"""
    account: ID
    filters: CommentFiltersInput
  ): Int!
  comments(
    """Returns the items in the list that come after the specified cursor."""
    after: String

    """Returns the first n items from the list."""
    first: Int

    """Returns the items in the list that come before the specified cursor."""
    before: String

    """Returns the last n items from the list."""
    last: Int

    """Returns only documents created by the provided account"""
    account: ID
    filters: CommentFiltersInput
    sorting: CommentSortingInput
  ): CommentConnection!
  favorites(
    """Returns the items in the list that come after the specified cursor."""
    after: String

    """Returns the first n items from the list."""
    first: Int

    """Returns the items in the list that come before the specified cursor."""
    before: String

    """Returns the last n items from the list."""
    last: Int

    """Returns only documents created by the provided account"""
    account: ID
  ): FavoriteConnection!
}

"""
A date-time string at UTC, such as 2007-12-03T10:15:30Z, compliant with the \`date-time\` format outlined in section 5.6 of the RFC 3339 profile of the ISO 8601 standard for representation of dates and times using the Gregorian calendar.
"""
scalar DateTime

"""A Ceramic Commit ID"""
scalar CeramicCommitID @specifiedBy(url: "https://cips.ceramic.network/CIPs/cip-59#commitid")

input CommentFiltersInput {
  where: CommentObjectFilterInput
  and: [CommentFiltersInput!]
  or: [CommentFiltersInput!]
  not: CommentFiltersInput
}

input CommentObjectFilterInput {
  text: StringValueFilterInput
}

input StringValueFilterInput {
  isNull: Boolean
  equalTo: String
  notEqualTo: String
  in: [String!]
  notIn: [String!]
  lessThan: String
  lessThanOrEqualTo: String
  greaterThan: String
  greaterThanOrEqualTo: String
}

"""A connection to a list of items."""
type CommentConnection {
  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """A list of edges."""
  edges: [CommentEdge]
}

"""An edge in a connection."""
type CommentEdge {
  """The item at the end of the edge"""
  node: Comment

  """A cursor for use in pagination"""
  cursor: String!
}

type Comment implements Node {
  id: ID!
  text: String!
  postID: CeramicStreamID!
  post: Post

  """Account controlling the document"""
  author: CeramicAccount!

  """Current version of the document"""
  version: CeramicCommitID!
}

input CommentSortingInput {
  text: SortOrder
}

enum SortOrder {
  ASC
  DESC
}

input PostFiltersInput {
  where: PostObjectFilterInput
  and: [PostFiltersInput!]
  or: [PostFiltersInput!]
  not: PostFiltersInput
}

input PostObjectFilterInput {
  title: StringValueFilterInput
}

input PostSortingInput {
  title: SortOrder
}

type Mutation {
  setFavorite(input: SetFavoriteInput!): SetFavoritePayload
  updateFavorite(input: UpdateFavoriteInput!): UpdateFavoritePayload
  hideFavorite(input: HideFavoriteInput!): HideFavoritePayload
  createPost(input: CreatePostInput!): CreatePostPayload
  updatePost(input: UpdatePostInput!): UpdatePostPayload
  hidePost(input: HidePostInput!): HidePostPayload
  createComment(input: CreateCommentInput!): CreateCommentPayload
  updateComment(input: UpdateCommentInput!): UpdateCommentPayload
  hideComment(input: HideCommentInput!): HideCommentPayload
}

type SetFavoritePayload {
  """Fetches an object given its ID"""
  node(
    """The ID of an object"""
    id: ID!
  ): Node

  """Account currently authenticated on the Ceramic instance, if set"""
  viewer: CeramicAccount
  document: Favorite!
  clientMutationId: String
}

input SetFavoriteInput {
  content: FavoriteInput!
  options: SetOptionsInput
  clientMutationId: String
}

input FavoriteInput {
  tag: String!
  note: String
  docID: CeramicStreamID!
}

input SetOptionsInput {
  """
  Maximum amount of time to lookup the stream over the network, in seconds - see https://developers.ceramic.network/reference/typescript/interfaces/_ceramicnetwork_common.CreateOpts.html#syncTimeoutSeconds
  """
  syncTimeout: Int
}

type UpdateFavoritePayload {
  """Fetches an object given its ID"""
  node(
    """The ID of an object"""
    id: ID!
  ): Node

  """Account currently authenticated on the Ceramic instance, if set"""
  viewer: CeramicAccount
  document: Favorite!
  clientMutationId: String
}

input UpdateFavoriteInput {
  id: ID!
  content: PartialFavoriteInput!
  options: UpdateOptionsInput
  clientMutationId: String
}

input PartialFavoriteInput {
  tag: String
  note: String
  docID: CeramicStreamID
}

input UpdateOptionsInput {
  """
  Fully replace the document contents instead of performing a shallow merge
  """
  replace: Boolean = false

  """Only perform mutation if the document matches the provided version"""
  version: CeramicCommitID
}

type HideFavoritePayload {
  """Fetches an object given its ID"""
  node(
    """The ID of an object"""
    id: ID!
  ): Node

  """Account currently authenticated on the Ceramic instance, if set"""
  viewer: CeramicAccount
  document: Favorite
  clientMutationId: String
}

input HideFavoriteInput {
  id: ID!
  options: HideOptionsInput
  clientMutationId: String
}

input HideOptionsInput {
  """DID for the signer(Optional)"""
  asDID: DID

  """Ceramic signer (Optional)"""
  signer: CeramicSignerInput
}

"""
A field whose value conforms to the standard DID format as specified in did-core: https://www.w3.org/TR/did-core/.
"""
scalar DID @specifiedBy(url: "https://www.w3.org/TR/did-core/")

input CeramicSignerInput {
  isAuthenticated: Boolean
}

type CreatePostPayload {
  """Fetches an object given its ID"""
  node(
    """The ID of an object"""
    id: ID!
  ): Node

  """Account currently authenticated on the Ceramic instance, if set"""
  viewer: CeramicAccount
  document: Post!
  clientMutationId: String
}

input CreatePostInput {
  content: PostInput!
  clientMutationId: String
}

input PostInput {
  date: DateTime
  text: String!
  title: String!
}

type UpdatePostPayload {
  """Fetches an object given its ID"""
  node(
    """The ID of an object"""
    id: ID!
  ): Node

  """Account currently authenticated on the Ceramic instance, if set"""
  viewer: CeramicAccount
  document: Post!
  clientMutationId: String
}

input UpdatePostInput {
  id: ID!
  content: PartialPostInput!
  options: UpdateOptionsInput
  clientMutationId: String
}

input PartialPostInput {
  date: DateTime
  text: String
  title: String
}

type HidePostPayload {
  """Fetches an object given its ID"""
  node(
    """The ID of an object"""
    id: ID!
  ): Node

  """Account currently authenticated on the Ceramic instance, if set"""
  viewer: CeramicAccount
  document: Post
  clientMutationId: String
}

input HidePostInput {
  id: ID!
  options: HideOptionsInput
  clientMutationId: String
}

type CreateCommentPayload {
  """Fetches an object given its ID"""
  node(
    """The ID of an object"""
    id: ID!
  ): Node

  """Account currently authenticated on the Ceramic instance, if set"""
  viewer: CeramicAccount
  document: Comment!
  clientMutationId: String
}

input CreateCommentInput {
  content: CommentInput!
  clientMutationId: String
}

input CommentInput {
  text: String!
  postID: CeramicStreamID!
}

type UpdateCommentPayload {
  """Fetches an object given its ID"""
  node(
    """The ID of an object"""
    id: ID!
  ): Node

  """Account currently authenticated on the Ceramic instance, if set"""
  viewer: CeramicAccount
  document: Comment!
  clientMutationId: String
}

input UpdateCommentInput {
  id: ID!
  content: PartialCommentInput!
  options: UpdateOptionsInput
  clientMutationId: String
}

input PartialCommentInput {
  text: String
  postID: CeramicStreamID
}

type HideCommentPayload {
  """Fetches an object given its ID"""
  node(
    """The ID of an object"""
    id: ID!
  ): Node

  """Account currently authenticated on the Ceramic instance, if set"""
  viewer: CeramicAccount
  document: Comment
  clientMutationId: String
}

input HideCommentInput {
  id: ID!
  options: HideOptionsInput
  clientMutationId: String
}"
`;

exports[`runtime SET account relation support 2`] = `
{
  "setFavorite": {
    "document": {
      "doc": {
        "title": "Test post 1",
      },
    },
    "viewer": {
      "favoriteList": {
        "edges": [
          {
            "node": {
              "doc": {
                "title": "Test post 1",
              },
              "tag": "posts",
            },
          },
        ],
      },
    },
  },
}
`;

exports[`runtime SET account relation support 3`] = `
{
  "setFavorite": {
    "document": {
      "doc": {
        "title": "Test post 2",
      },
    },
    "viewer": {
      "favoriteList": {
        "edges": [
          {
            "node": {
              "doc": {
                "title": "Test post 1",
              },
              "tag": "posts",
            },
          },
          {
            "node": {
              "doc": {
                "title": "Test post 2",
              },
              "tag": "posts",
            },
          },
        ],
      },
    },
  },
}
`;

exports[`runtime can create a document using extra scalars 1`] = `
{
  "accountID": "eip155:1:0xabcdef",
  "chainID": "eip155:1",
  "cid": "bagcqcerakszw2vsovxznyp5gfnpdj4cqm2xiv76yd24wkjewhhykovorwo6a",
  "commitID": "k1dpgaqe3i64kjqcp801r3sn7ysi5i0k7nxvs7j351s7kewfzr3l7mdxnj7szwo4kr9mn2qki5nnj0cv836ythy1t1gya9s25cn1nexst3jxi5o3h6qprfyju",
  "countryCode": "US",
  "date": "2023-01-31",
  "dateTime": "2023-01-31T16:04:16.475Z",
  "did": {
    "id": "did:test:123",
  },
  "duration": "P1Y2M22DT5H24M15S",
  "latitude": 53.471,
  "localDate": "2023-01-31",
  "localTime": "14:25:06.123",
  "locale": "en-gb",
  "longitude": 53.471,
  "streamID": "kjzl6cwe1jw147dvq16zluojmraqvwdmbh61dx9e0c59i344lcrsgqfohexp60s",
  "time": "14:10:20+01:00",
  "timeZone": null,
  "uri": "https://ceramic.network",
  "utcOffset": "+01:15",
}
`;

exports[`runtime create and query post with comments 1`] = `
"type Query {
  """Fetches objects given their IDs"""
  nodes(
    """The IDs of objects"""
    ids: [ID!]!
  ): [Node]!

  """Fetches an object given its ID"""
  node(
    """The ID of an object"""
    id: ID!
  ): Node

  """Account currently authenticated on the Ceramic instance, if set"""
  viewer: CeramicAccount
  postIndex(
    """Returns the items in the list that come after the specified cursor."""
    after: String

    """Returns the first n items from the list."""
    first: Int

    """Returns the items in the list that come before the specified cursor."""
    before: String

    """Returns the last n items from the list."""
    last: Int
    filters: PostFiltersInput
    sorting: PostSortingInput
  ): PostConnection
  postCount(filters: PostFiltersInput): Int!
  commentIndex(
    """Returns the items in the list that come after the specified cursor."""
    after: String

    """Returns the first n items from the list."""
    first: Int

    """Returns the items in the list that come before the specified cursor."""
    before: String

    """Returns the last n items from the list."""
    last: Int
    filters: CommentFiltersInput
    sorting: CommentSortingInput
  ): CommentConnection
  commentCount(filters: CommentFiltersInput): Int!
}

"""An object with an ID"""
interface Node {
  """The id of the object."""
  id: ID!
}

type CeramicAccount implements Node {
  """Globally unique identifier of the account (DID string)"""
  id: ID!

  """
  Whether the Ceramic instance is currently authenticated with this account or not
  """
  isViewer: Boolean!
  postList(
    """Returns the items in the list that come after the specified cursor."""
    after: String

    """Returns the first n items from the list."""
    first: Int

    """Returns the items in the list that come before the specified cursor."""
    before: String

    """Returns the last n items from the list."""
    last: Int
    filters: PostFiltersInput
    sorting: PostSortingInput
  ): PostConnection
  postListCount(filters: PostFiltersInput): Int!
  commentList(
    """Returns the items in the list that come after the specified cursor."""
    after: String

    """Returns the first n items from the list."""
    first: Int

    """Returns the items in the list that come before the specified cursor."""
    before: String

    """Returns the last n items from the list."""
    last: Int
    filters: CommentFiltersInput
    sorting: CommentSortingInput
  ): CommentConnection
  commentListCount(filters: CommentFiltersInput): Int!
}

"""A connection to a list of items."""
type PostConnection {
  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """A list of edges."""
  edges: [PostEdge]
}

"""Information about pagination in a connection."""
type PageInfo {
  """When paginating forwards, are there more items?"""
  hasNextPage: Boolean!

  """When paginating backwards, are there more items?"""
  hasPreviousPage: Boolean!

  """When paginating backwards, the cursor to continue."""
  startCursor: String

  """When paginating forwards, the cursor to continue."""
  endCursor: String
}

"""An edge in a connection."""
type PostEdge {
  """The item at the end of the edge"""
  node: Post

  """A cursor for use in pagination"""
  cursor: String!
}

type Post implements Node {
  id: ID!
  date: DateTime
  text: String!
  title: String!

  """Account controlling the document"""
  author: CeramicAccount!

  """Current version of the document"""
  version: CeramicCommitID!
  commentsCount(
    """Counts only documents created by the provided account"""
    account: ID
    filters: CommentFiltersInput
  ): Int!
  comments(
    """Returns the items in the list that come after the specified cursor."""
    after: String

    """Returns the first n items from the list."""
    first: Int

    """Returns the items in the list that come before the specified cursor."""
    before: String

    """Returns the last n items from the list."""
    last: Int

    """Returns only documents created by the provided account"""
    account: ID
    filters: CommentFiltersInput
    sorting: CommentSortingInput
  ): CommentConnection!
}

"""
A date-time string at UTC, such as 2007-12-03T10:15:30Z, compliant with the \`date-time\` format outlined in section 5.6 of the RFC 3339 profile of the ISO 8601 standard for representation of dates and times using the Gregorian calendar.
"""
scalar DateTime

"""A Ceramic Commit ID"""
scalar CeramicCommitID @specifiedBy(url: "https://cips.ceramic.network/CIPs/cip-59#commitid")

input CommentFiltersInput {
  where: CommentObjectFilterInput
  and: [CommentFiltersInput!]
  or: [CommentFiltersInput!]
  not: CommentFiltersInput
}

input CommentObjectFilterInput {
  text: StringValueFilterInput
}

input StringValueFilterInput {
  isNull: Boolean
  equalTo: String
  notEqualTo: String
  in: [String!]
  notIn: [String!]
  lessThan: String
  lessThanOrEqualTo: String
  greaterThan: String
  greaterThanOrEqualTo: String
}

"""A connection to a list of items."""
type CommentConnection {
  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """A list of edges."""
  edges: [CommentEdge]
}

"""An edge in a connection."""
type CommentEdge {
  """The item at the end of the edge"""
  node: Comment

  """A cursor for use in pagination"""
  cursor: String!
}

type Comment implements Node {
  id: ID!
  text: String!
  postID: CeramicStreamID!
  post: Post

  """Account controlling the document"""
  author: CeramicAccount!

  """Current version of the document"""
  version: CeramicCommitID!
}

"""A Ceramic Stream ID"""
scalar CeramicStreamID @specifiedBy(url: "https://cips.ceramic.network/CIPs/cip-59#streamid")

input CommentSortingInput {
  text: SortOrder
}

enum SortOrder {
  ASC
  DESC
}

input PostFiltersInput {
  where: PostObjectFilterInput
  and: [PostFiltersInput!]
  or: [PostFiltersInput!]
  not: PostFiltersInput
}

input PostObjectFilterInput {
  title: StringValueFilterInput
}

input PostSortingInput {
  title: SortOrder
}

type Mutation {
  createPost(input: CreatePostInput!): CreatePostPayload
  updatePost(input: UpdatePostInput!): UpdatePostPayload
  hidePost(input: HidePostInput!): HidePostPayload
  createComment(input: CreateCommentInput!): CreateCommentPayload
  updateComment(input: UpdateCommentInput!): UpdateCommentPayload
  hideComment(input: HideCommentInput!): HideCommentPayload
}

type CreatePostPayload {
  """Fetches an object given its ID"""
  node(
    """The ID of an object"""
    id: ID!
  ): Node

  """Account currently authenticated on the Ceramic instance, if set"""
  viewer: CeramicAccount
  document: Post!
  clientMutationId: String
}

input CreatePostInput {
  content: PostInput!
  clientMutationId: String
}

input PostInput {
  date: DateTime
  text: String!
  title: String!
}

type UpdatePostPayload {
  """Fetches an object given its ID"""
  node(
    """The ID of an object"""
    id: ID!
  ): Node

  """Account currently authenticated on the Ceramic instance, if set"""
  viewer: CeramicAccount
  document: Post!
  clientMutationId: String
}

input UpdatePostInput {
  id: ID!
  content: PartialPostInput!
  options: UpdateOptionsInput
  clientMutationId: String
}

input PartialPostInput {
  date: DateTime
  text: String
  title: String
}

input UpdateOptionsInput {
  """
  Fully replace the document contents instead of performing a shallow merge
  """
  replace: Boolean = false

  """Only perform mutation if the document matches the provided version"""
  version: CeramicCommitID
}

type HidePostPayload {
  """Fetches an object given its ID"""
  node(
    """The ID of an object"""
    id: ID!
  ): Node

  """Account currently authenticated on the Ceramic instance, if set"""
  viewer: CeramicAccount
  document: Post
  clientMutationId: String
}

input HidePostInput {
  id: ID!
  options: HideOptionsInput
  clientMutationId: String
}

input HideOptionsInput {
  """DID for the signer(Optional)"""
  asDID: DID

  """Ceramic signer (Optional)"""
  signer: CeramicSignerInput
}

"""
A field whose value conforms to the standard DID format as specified in did-core: https://www.w3.org/TR/did-core/.
"""
scalar DID @specifiedBy(url: "https://www.w3.org/TR/did-core/")

input CeramicSignerInput {
  isAuthenticated: Boolean
}

type CreateCommentPayload {
  """Fetches an object given its ID"""
  node(
    """The ID of an object"""
    id: ID!
  ): Node

  """Account currently authenticated on the Ceramic instance, if set"""
  viewer: CeramicAccount
  document: Comment!
  clientMutationId: String
}

input CreateCommentInput {
  content: CommentInput!
  clientMutationId: String
}

input CommentInput {
  text: String!
  postID: CeramicStreamID!
}

type UpdateCommentPayload {
  """Fetches an object given its ID"""
  node(
    """The ID of an object"""
    id: ID!
  ): Node

  """Account currently authenticated on the Ceramic instance, if set"""
  viewer: CeramicAccount
  document: Comment!
  clientMutationId: String
}

input UpdateCommentInput {
  id: ID!
  content: PartialCommentInput!
  options: UpdateOptionsInput
  clientMutationId: String
}

input PartialCommentInput {
  text: String
  postID: CeramicStreamID
}

type HideCommentPayload {
  """Fetches an object given its ID"""
  node(
    """The ID of an object"""
    id: ID!
  ): Node

  """Account currently authenticated on the Ceramic instance, if set"""
  viewer: CeramicAccount
  document: Comment
  clientMutationId: String
}

input HideCommentInput {
  id: ID!
  options: HideOptionsInput
  clientMutationId: String
}"
`;

exports[`runtime create and query post with comments 2`] = `
{
  "data": {
    "comments": [
      {
        "text": "A first comment",
      },
      {
        "text": "A second comment",
      },
      {
        "text": "A third comment",
      },
    ],
    "viewer": {
      "postList": {
        "edges": [
          {
            "node": {
              "comments": {
                "edges": [],
              },
              "commentsCount": 0,
              "text": "First post content",
              "title": "A first post",
            },
          },
          {
            "node": {
              "comments": {
                "edges": [
                  {
                    "node": {
                      "text": "A first comment",
                    },
                  },
                  {
                    "node": {
                      "text": "A second comment",
                    },
                  },
                  {
                    "node": {
                      "text": "A third comment",
                    },
                  },
                ],
              },
              "commentsCount": 3,
              "text": "Second post content",
              "title": "A second post",
            },
          },
        ],
      },
    },
  },
}
`;

exports[`runtime create and query ratings with filters and ordering 1`] = `
{
  "data": {
    "viewer": {
      "ratingList": {
        "edges": [
          {
            "node": {
              "title": "one",
              "value": 5,
            },
          },
        ],
      },
    },
  },
}
`;

exports[`runtime create and query ratings with filters and ordering 2`] = `
{
  "data": {
    "viewer": {
      "ratingList": {
        "edges": [
          {
            "node": {
              "title": "two",
              "value": 2.5,
            },
          },
          {
            "node": {
              "title": "three",
              "value": 3.5,
            },
          },
          {
            "node": {
              "title": "one",
              "value": 5,
            },
          },
        ],
      },
    },
  },
}
`;

exports[`runtime create and query ratings with filters and ordering 3`] = `
{
  "data": {
    "viewer": {
      "ratingList": {
        "edges": [
          {
            "node": {
              "title": "one",
              "value": 5,
            },
          },
          {
            "node": {
              "title": "three",
              "value": 3.5,
            },
          },
          {
            "node": {
              "title": "two",
              "value": 2.5,
            },
          },
        ],
      },
    },
  },
}
`;

exports[`runtime create and update a document with enum 1`] = `
{
  "status": "DEFAULT",
  "text": "Test node contents",
  "title": "A test note",
}
`;

exports[`runtime create and update a document with enum 2`] = `
{
  "status": null,
  "text": "New note contents",
  "title": "A test note",
}
`;

exports[`runtime interfaces queries 1`] = `
{
  "data": {
    "mediaMetadataIndex": {
      "edges": [
        {
          "node": {
            "__typename": "MyImage",
            "height": 600,
            "src": "http://my/image1",
            "width": 800,
          },
        },
        {
          "node": {
            "__typename": "MyImage",
            "height": 800,
            "src": "http://my/image2",
            "width": 1600,
          },
        },
        {
          "node": {
            "__typename": "MyAudio",
            "duration": "PT2M36S",
            "src": "http://my/audio1",
          },
        },
        {
          "node": {
            "__typename": "MyAudio",
            "duration": "PT5M4S",
            "src": "http://my/audio2",
          },
        },
        {
          "node": {
            "__typename": "MyVideo",
            "duration": "PT2H5M48S",
            "height": 1080,
            "src": "http://my/video1",
            "width": 1920,
          },
        },
        {
          "node": {
            "__typename": "MyVideo",
            "duration": "PT1H34M15S",
            "height": 2160,
            "src": "http://my/video2",
            "width": 4096,
          },
        },
      ],
    },
  },
}
`;

exports[`runtime interfaces queries 2`] = `
{
  "data": {
    "visualMediaIndex": {
      "edges": [
        {
          "node": {
            "__typename": "MyVideo",
            "height": 2160,
            "src": "http://my/video2",
            "width": 4096,
          },
        },
        {
          "node": {
            "__typename": "MyVideo",
            "height": 1080,
            "src": "http://my/video1",
            "width": 1920,
          },
        },
        {
          "node": {
            "__typename": "MyImage",
            "height": 800,
            "src": "http://my/image2",
            "width": 1600,
          },
        },
      ],
    },
  },
}
`;

exports[`runtime interfaces queries 3`] = `
{
  "data": {
    "collection1": {
      "items": {
        "edges": [
          {
            "node": {
              "item": {
                "__typename": "MyVideo",
                "src": "http://my/video1",
              },
            },
          },
          {
            "node": {
              "item": {
                "__typename": "MyVideo",
                "src": "http://my/video2",
              },
            },
          },
          {
            "node": {
              "item": {
                "__typename": "MyImage",
                "src": "http://my/image2",
              },
            },
          },
          {
            "node": {
              "item": {
                "__typename": "MyImage",
                "src": "http://my/image1",
              },
            },
          },
          {
            "node": {
              "item": {
                "__typename": "MyAudio",
                "src": "http://my/audio2",
              },
            },
          },
        ],
      },
      "itemsCount": 5,
    },
    "video2": {
      "collectionItems": {
        "edges": [
          {
            "node": {
              "collection": {
                "name": "First collection",
              },
            },
          },
          {
            "node": {
              "collection": {
                "name": "Second collection",
              },
            },
          },
        ],
      },
      "collectionItemsCount": 2,
    },
  },
}
`;

exports[`runtime relation to account reference 1`] = `
{
  "data": {
    "alice": {
      "met": {
        "edges": [],
      },
      "metBy": {
        "edges": [
          {
            "node": {
              "self": {
                "id": "did:key:z6MkiTBz1ymuepAQ4HEHYSF1H8quG5GLVVQR3djdX3mDooWp",
              },
            },
          },
        ],
      },
      "metByCount": 1,
      "metCount": 0,
    },
    "bob": {
      "met": {
        "edges": [],
      },
      "metBy": {
        "edges": [
          {
            "node": {
              "self": {
                "id": "did:key:z6MkiTBz1ymuepAQ4HEHYSF1H8quG5GLVVQR3djdX3mDooWp",
              },
            },
          },
          {
            "node": {
              "self": {
                "id": "did:key:z6MkiTBz1ymuepAQ4HEHYSF1H8quG5GLVVQR3djdX3mDooWp",
              },
            },
          },
          {
            "node": {
              "self": {
                "id": "did:key:z6MkiTBz1ymuepAQ4HEHYSF1H8quG5GLVVQR3djdX3mDooWp",
              },
            },
          },
        ],
      },
      "metByCount": 3,
      "metCount": 0,
    },
    "viewer": {
      "id": "did:key:z6MkiTBz1ymuepAQ4HEHYSF1H8quG5GLVVQR3djdX3mDooWp",
      "met": {
        "edges": [
          {
            "node": {
              "other": {
                "id": "did:test:bob",
              },
            },
          },
          {
            "node": {
              "other": {
                "id": "did:test:alice",
              },
            },
          },
          {
            "node": {
              "other": {
                "id": "did:test:bob",
              },
            },
          },
          {
            "node": {
              "other": {
                "id": "did:test:bob",
              },
            },
          },
        ],
      },
      "metBy": {
        "edges": [],
      },
      "metByCount": 0,
      "metCount": 4,
    },
  },
}
`;

exports[`runtime runtime operations on models with immutable field 1`] = `
"type Query {
  """Fetches objects given their IDs"""
  nodes(
    """The IDs of objects"""
    ids: [ID!]!
  ): [Node]!

  """Fetches an object given its ID"""
  node(
    """The ID of an object"""
    id: ID!
  ): Node

  """Account currently authenticated on the Ceramic instance, if set"""
  viewer: CeramicAccount
  testInterfaceIndex(
    """Returns the items in the list that come after the specified cursor."""
    after: String

    """Returns the first n items from the list."""
    first: Int

    """Returns the items in the list that come before the specified cursor."""
    before: String

    """Returns the last n items from the list."""
    last: Int
    filters: TestInterfaceFiltersInput
    sorting: TestInterfaceSortingInput
  ): TestInterfaceConnection
  testInterfaceCount(filters: TestInterfaceFiltersInput): Int!
  postIndex(
    """Returns the items in the list that come after the specified cursor."""
    after: String

    """Returns the first n items from the list."""
    first: Int

    """Returns the items in the list that come before the specified cursor."""
    before: String

    """Returns the last n items from the list."""
    last: Int
    filters: PostFiltersInput
    sorting: PostSortingInput
  ): PostConnection
  postCount(filters: PostFiltersInput): Int!
}

"""An object with an ID"""
interface Node {
  """The id of the object."""
  id: ID!
}

type CeramicAccount implements Node {
  """Globally unique identifier of the account (DID string)"""
  id: ID!

  """
  Whether the Ceramic instance is currently authenticated with this account or not
  """
  isViewer: Boolean!
  testInterfaceList(
    """Returns the items in the list that come after the specified cursor."""
    after: String

    """Returns the first n items from the list."""
    first: Int

    """Returns the items in the list that come before the specified cursor."""
    before: String

    """Returns the last n items from the list."""
    last: Int
    filters: TestInterfaceFiltersInput
    sorting: TestInterfaceSortingInput
  ): TestInterfaceConnection
  testInterfaceListCount(filters: TestInterfaceFiltersInput): Int!
  postList(
    """Returns the items in the list that come after the specified cursor."""
    after: String

    """Returns the first n items from the list."""
    first: Int

    """Returns the items in the list that come before the specified cursor."""
    before: String

    """Returns the last n items from the list."""
    last: Int
    filters: PostFiltersInput
    sorting: PostSortingInput
  ): PostConnection
  postListCount(filters: PostFiltersInput): Int!
}

"""A connection to a list of items."""
type TestInterfaceConnection {
  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """A list of edges."""
  edges: [TestInterfaceEdge]
}

"""Information about pagination in a connection."""
type PageInfo {
  """When paginating forwards, are there more items?"""
  hasNextPage: Boolean!

  """When paginating backwards, are there more items?"""
  hasPreviousPage: Boolean!

  """When paginating backwards, the cursor to continue."""
  startCursor: String

  """When paginating forwards, the cursor to continue."""
  endCursor: String
}

"""An edge in a connection."""
type TestInterfaceEdge {
  """The item at the end of the edge"""
  node: TestInterface

  """A cursor for use in pagination"""
  cursor: String!
}

interface TestInterface {
  testField: String
}

input TestInterfaceFiltersInput {
  where: TestInterfaceObjectFilterInput
  and: [TestInterfaceFiltersInput!]
  or: [TestInterfaceFiltersInput!]
  not: TestInterfaceFiltersInput
}

input TestInterfaceObjectFilterInput {
  testField: StringValueFilterInput
}

input StringValueFilterInput {
  isNull: Boolean
  equalTo: String
  notEqualTo: String
  in: [String!]
  notIn: [String!]
  lessThan: String
  lessThanOrEqualTo: String
  greaterThan: String
  greaterThanOrEqualTo: String
}

input TestInterfaceSortingInput {
  testField: SortOrder
}

enum SortOrder {
  ASC
  DESC
}

"""A connection to a list of items."""
type PostConnection {
  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """A list of edges."""
  edges: [PostEdge]
}

"""An edge in a connection."""
type PostEdge {
  """The item at the end of the edge"""
  node: Post

  """A cursor for use in pagination"""
  cursor: String!
}

type Post implements Node & TestInterface {
  id: ID!
  date: DateTime
  text: String!
  title: String!
  testField: String

  """Account controlling the document"""
  author: CeramicAccount!
}

"""
A date-time string at UTC, such as 2007-12-03T10:15:30Z, compliant with the \`date-time\` format outlined in section 5.6 of the RFC 3339 profile of the ISO 8601 standard for representation of dates and times using the Gregorian calendar.
"""
scalar DateTime

input PostFiltersInput {
  where: PostObjectFilterInput
  and: [PostFiltersInput!]
  or: [PostFiltersInput!]
  not: PostFiltersInput
}

input PostObjectFilterInput {
  title: StringValueFilterInput
}

input PostSortingInput {
  title: SortOrder
}

type Mutation {
  createPost(input: CreatePostInput!): CreatePostPayload
  updatePost(input: UpdatePostInput!): UpdatePostPayload
  hidePost(input: HidePostInput!): HidePostPayload
}

type CreatePostPayload {
  """Fetches an object given its ID"""
  node(
    """The ID of an object"""
    id: ID!
  ): Node

  """Account currently authenticated on the Ceramic instance, if set"""
  viewer: CeramicAccount
  document: Post!
  clientMutationId: String
}

input CreatePostInput {
  content: PostInput!
  clientMutationId: String
}

input PostInput {
  date: DateTime
  text: String!
  title: String!
  testField: String
}

type UpdatePostPayload {
  """Fetches an object given its ID"""
  node(
    """The ID of an object"""
    id: ID!
  ): Node

  """Account currently authenticated on the Ceramic instance, if set"""
  viewer: CeramicAccount
  document: Post!
  clientMutationId: String
}

input UpdatePostInput {
  id: ID!
  content: PartialPostInput!
  options: UpdateOptionsInput
  clientMutationId: String
}

input PartialPostInput {
  date: DateTime
  text: String
}

input UpdateOptionsInput {
  """
  Fully replace the document contents instead of performing a shallow merge
  """
  replace: Boolean = false

  """Only perform mutation if the document matches the provided version"""
  version: CeramicCommitID
}

"""A Ceramic Commit ID"""
scalar CeramicCommitID @specifiedBy(url: "https://cips.ceramic.network/CIPs/cip-59#commitid")

type HidePostPayload {
  """Fetches an object given its ID"""
  node(
    """The ID of an object"""
    id: ID!
  ): Node

  """Account currently authenticated on the Ceramic instance, if set"""
  viewer: CeramicAccount
  document: Post
  clientMutationId: String
}

input HidePostInput {
  id: ID!
  options: HideOptionsInput
  clientMutationId: String
}

input HideOptionsInput {
  """DID for the signer(Optional)"""
  asDID: DID

  """Ceramic signer (Optional)"""
  signer: CeramicSignerInput
}

"""
A field whose value conforms to the standard DID format as specified in did-core: https://www.w3.org/TR/did-core/.
"""
scalar DID @specifiedBy(url: "https://www.w3.org/TR/did-core/")

input CeramicSignerInput {
  isAuthenticated: Boolean
}"
`;
